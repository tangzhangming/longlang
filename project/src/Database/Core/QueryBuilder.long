namespace App.Database.Core

use App.Database.Exception.DatabaseException

/**
 * QueryBuilder - SQL 查询构建器
 */
public class QueryBuilder {
    private _connection any
    private _table string
    private _columns any
    private _distinct bool
    private _wheres any
    private _orders any
    private _groups any
    private _havings any
    private _joins any
    private _limit int
    private _offset int
    private _bindings any
    
    public function __construct(connection: any, table: string) {
        this._connection = connection
        this._table = this._prefixTable(table)
        this._columns = {}
        this._distinct = false
        this._wheres = {}
        this._orders = {}
        this._groups = {}
        this._havings = {}
        this._joins = {}
        this._limit = 0
        this._offset = 0
        this._bindings = {}
    }
    
    private function _prefixTable(table: string) string {
        prefix := this._connection.getConfig().getPrefix()
        if prefix != "" {
            return prefix + table
        }
        return table
    }
    
    // ==================== SELECT ====================
    
    public function select(columns: any) any {
        this._columns = {}
        if typeof(columns) == "ARRAY" {
            for i := 0; i < len(columns); i++ {
                this._columns.push(columns[i])
            }
        } else {
            this._columns.push(columns)
        }
        return this
    }
    
    public function addSelect(columns: any) any {
        if typeof(columns) == "ARRAY" {
            for i := 0; i < len(columns); i++ {
                this._columns.push(columns[i])
            }
        } else {
            this._columns.push(columns)
        }
        return this
    }
    
    public function distinct() any {
        this._distinct = true
        return this
    }
    
    // ==================== WHERE ====================
    
    public function where(column: string, operatorOrValue: any, value: any = null) any {
        if value == null {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": "=",
                "value": operatorOrValue,
                "boolean": "AND"
            })
        } else {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": operatorOrValue,
                "value": value,
                "boolean": "AND"
            })
        }
        return this
    }
    
    public function orWhere(column: string, operatorOrValue: any, value: any = null) any {
        if value == null {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": "=",
                "value": operatorOrValue,
                "boolean": "OR"
            })
        } else {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": operatorOrValue,
                "value": value,
                "boolean": "OR"
            })
        }
        return this
    }
    
    public function whereIn(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "in",
            "column": column,
            "values": values,
            "not": false,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNotIn(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "in",
            "column": column,
            "values": values,
            "not": true,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNull(column: string) any {
        this._wheres.push(map[string]any{
            "type": "null",
            "column": column,
            "not": false,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNotNull(column: string) any {
        this._wheres.push(map[string]any{
            "type": "null",
            "column": column,
            "not": true,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereBetween(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "between",
            "column": column,
            "values": values,
            "not": false,
            "boolean": "AND"
        })
        return this
    }
    
    // ==================== ORDER BY ====================
    
    public function orderBy(column: string, direction: string = "asc") any {
        dir := direction.upper()
        if dir != "ASC" && dir != "DESC" {
            dir = "ASC"
        }
        this._orders.push(map[string]any{
            "column": column,
            "direction": dir
        })
        return this
    }
    
    public function orderByDesc(column: string) any {
        return this.orderBy(column, "desc")
    }
    
    public function latest(column: string = "created_at") any {
        return this.orderBy(column, "desc")
    }
    
    public function oldest(column: string = "created_at") any {
        return this.orderBy(column, "asc")
    }
    
    // ==================== LIMIT / OFFSET ====================
    
    public function limit(limit: int) any {
        this._limit = limit
        return this
    }
    
    public function offset(offset: int) any {
        this._offset = offset
        return this
    }
    
    public function take(limit: int) any {
        return this.limit(limit)
    }
    
    public function skip(offset: int) any {
        return this.offset(offset)
    }
    
    // ==================== 执行查询 ====================
    
    public function get() any {
        sql := this._compileSelect()
        return this._connection.select(sql, this._bindings)
    }
    
    public function first() any {
        this.limit(1)
        results := this.get()
        if len(results) > 0 {
            return results[0]
        }
        return null
    }
    
    public function find(id: any) any {
        return this.where("id", id).first()
    }
    
    public function exists() bool {
        sql := "SELECT 1 FROM " + this._table + this._compileWheres() + " LIMIT 1"
        result := this._connection.select(sql, this._bindings)
        return len(result) > 0
    }
    
    public function doesntExist() bool {
        return !this.exists()
    }
    
    public function count(column: string = "*") int {
        sql := "SELECT COUNT(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return parseInt(toString(result[0]["aggregate"]))
        }
        return 0
    }
    
    public function max(column: string) any {
        sql := "SELECT MAX(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function min(column: string) any {
        sql := "SELECT MIN(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function avg(column: string) any {
        sql := "SELECT AVG(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function sum(column: string) any {
        sql := "SELECT SUM(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function value(column: string) any {
        result := this.select(column).first()
        if result != null {
            return result[column]
        }
        return null
    }
    
    public function pluck(column: string) any {
        results := this.select(column).get()
        values := {}
        for i := 0; i < len(results); i++ {
            values.push(results[i][column])
        }
        return values
    }
    
    // ==================== INSERT / UPDATE / DELETE ====================
    
    public function insert(data: any) bool {
        sql := this._compileInsert(data)
        return this._connection.statement(sql, this._bindings)
    }
    
    public function insertGetId(data: any) int {
        sql := this._compileInsert(data)
        return this._connection.insertGetId(sql, this._bindings)
    }
    
    public function update(data: any) int {
        sql := this._compileUpdate(data)
        return this._connection.update(sql, this._bindings)
    }
    
    public function delete() int {
        sql := this._compileDelete()
        return this._connection.delete(sql, this._bindings)
    }
    
    public function increment(column: string, amount: int = 1) int {
        sql := "UPDATE " + this._table + " SET " + column + " = " + column + " + " + toString(amount) + this._compileWheres()
        return this._connection.update(sql, this._bindings)
    }
    
    public function decrement(column: string, amount: int = 1) int {
        sql := "UPDATE " + this._table + " SET " + column + " = " + column + " - " + toString(amount) + this._compileWheres()
        return this._connection.update(sql, this._bindings)
    }
    
    // ==================== 调试 ====================
    
    public function toSql() string {
        return this._compileSelect()
    }
    
    public function getBindings() any {
        return this._bindings
    }
    
    // ==================== 内部编译方法 ====================
    
    private function _compileSelect() string {
        sql := "SELECT "
        
        if this._distinct {
            sql = sql + "DISTINCT "
        }
        
        if len(this._columns) == 0 {
            sql = sql + "*"
        } else {
            sql = sql + this._implode(this._columns, ", ")
        }
        
        sql = sql + " FROM " + this._table
        sql = sql + this._compileJoins()
        sql = sql + this._compileWheres()
        sql = sql + this._compileGroups()
        sql = sql + this._compileHavings()
        sql = sql + this._compileOrders()
        sql = sql + this._compileLimit()
        
        return sql
    }
    
    private function _compileInsert(data: any) string {
        columns := {}
        values := {}
        
        for key, value := range data {
            columns.push(key)
            values.push(this._connection._formatValue(value))
        }
        
        return "INSERT INTO " + this._table + " (" + this._implode(columns, ", ") + ") VALUES (" + this._implode(values, ", ") + ")"
    }
    
    private function _compileUpdate(data: any) string {
        setParts := {}
        
        for key, value := range data {
            setParts.push(key + " = " + this._connection._formatValue(value))
        }
        
        return "UPDATE " + this._table + " SET " + this._implode(setParts, ", ") + this._compileWheres()
    }
    
    private function _compileDelete() string {
        return "DELETE FROM " + this._table + this._compileWheres()
    }
    
    private function _compileWheres() string {
        if len(this._wheres) == 0 {
            return ""
        }
        
        sql := " WHERE "
        first := true
        
        for i := 0; i < len(this._wheres); i++ {
            w := this._wheres[i]
            
            if !first {
                sql = sql + " " + w["boolean"] + " "
            }
            first = false
            
            wType := w["type"]
            
            if wType == "basic" {
                sql = sql + w["column"] + " " + w["operator"] + " " + this._connection._formatValue(w["value"])
            } else if wType == "in" {
                values := w["values"]
                valueStrs := {}
                for j := 0; j < len(values); j++ {
                    valueStrs.push(this._connection._formatValue(values[j]))
                }
                inStr := this._implode(valueStrs, ", ")
                if w["not"] {
                    sql = sql + w["column"] + " NOT IN (" + inStr + ")"
                } else {
                    sql = sql + w["column"] + " IN (" + inStr + ")"
                }
            } else if wType == "null" {
                if w["not"] {
                    sql = sql + w["column"] + " IS NOT NULL"
                } else {
                    sql = sql + w["column"] + " IS NULL"
                }
            } else if wType == "between" {
                values := w["values"]
                if w["not"] {
                    sql = sql + w["column"] + " NOT BETWEEN " + this._connection._formatValue(values[0]) + " AND " + this._connection._formatValue(values[1])
                } else {
                    sql = sql + w["column"] + " BETWEEN " + this._connection._formatValue(values[0]) + " AND " + this._connection._formatValue(values[1])
                }
            }
        }
        
        return sql
    }
    
    private function _compileJoins() string {
        if len(this._joins) == 0 {
            return ""
        }
        
        sql := ""
        for i := 0; i < len(this._joins); i++ {
            j := this._joins[i]
            sql = sql + " " + j["type"] + " JOIN " + j["table"]
            sql = sql + " ON " + j["first"] + " " + j["operator"] + " " + j["second"]
        }
        
        return sql
    }
    
    private function _compileOrders() string {
        if len(this._orders) == 0 {
            return ""
        }
        
        parts := {}
        for i := 0; i < len(this._orders); i++ {
            order := this._orders[i]
            parts.push(order["column"] + " " + order["direction"])
        }
        
        return " ORDER BY " + this._implode(parts, ", ")
    }
    
    private function _compileGroups() string {
        if len(this._groups) == 0 {
            return ""
        }
        return " GROUP BY " + this._implode(this._groups, ", ")
    }
    
    private function _compileHavings() string {
        if len(this._havings) == 0 {
            return ""
        }
        
        sql := " HAVING "
        first := true
        
        for i := 0; i < len(this._havings); i++ {
            h := this._havings[i]
            
            if !first {
                sql = sql + " " + h["boolean"] + " "
            }
            first = false
            
            sql = sql + h["column"] + " " + h["operator"] + " " + this._connection._formatValue(h["value"])
        }
        
        return sql
    }
    
    private function _compileLimit() string {
        limitSql := ""
        if this._limit > 0 {
            limitSql = " LIMIT " + toString(this._limit)
        }
        if this._offset > 0 {
            limitSql = limitSql + " OFFSET " + toString(this._offset)
        }
        return limitSql
    }
    
    private function _implode(arr: any, separator: string) string {
        if len(arr) == 0 {
            return ""
        }
        result := toString(arr[0])
        for i := 1; i < len(arr); i++ {
            result = result + separator + toString(arr[i])
        }
        return result
    }
}



namespace App.Database.Core

use App.Database.Exception.DatabaseException

/**
 * QueryBuilder - SQL 查询构建器
 * 支持 Laravel 风格的链式查询
 */
public class QueryBuilder {
    private _connection any
    private _table string
    private _columns any
    private _distinct bool
    private _wheres any
    private _orders any
    private _groups any
    private _havings any
    private _joins any
    private _limit int
    private _offset int
    private _bindings any
    private _selectRaw string
    private _orderRaw string
    private _havingRaw string
    
    public function __construct(connection: any, table: string) {
        this._connection = connection
        this._table = this._prefixTable(table)
        this._columns = {}
        this._distinct = false
        this._wheres = {}
        this._orders = {}
        this._groups = {}
        this._havings = {}
        this._joins = {}
        this._limit = 0
        this._offset = 0
        this._bindings = {}
        this._selectRaw = ""
        this._orderRaw = ""
        this._havingRaw = ""
    }
    
    private function _prefixTable(table: string) string {
        prefix := this._connection.getConfig().getPrefix()
        if prefix != "" {
            return prefix + table
        }
        return table
    }
    
    // ==================== SELECT ====================
    
    public function select(columns: any) any {
        this._columns = {}
        if typeof(columns) == "ARRAY" {
            for i := 0; i < len(columns); i++ {
                this._columns.push(columns[i])
            }
        } else {
            this._columns.push(columns)
        }
        return this
    }
    
    public function selectRaw(expression: string, bindings: any = {}) any {
        this._selectRaw = expression
        this._addBindings(bindings)
        return this
    }
    
    public function distinct() any {
        this._distinct = true
        return this
    }
    
    // ==================== WHERE ====================
    
    public function where(column: any, operatorOrValue: any = null, value: any = null) any {
        // 检查是否是闭包
        if typeof(column) == "FUNCTION" {
            return this._whereNested(column, "AND")
        }
        
        if value == null {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": "=",
                "value": operatorOrValue,
                "boolean": "AND"
            })
        } else {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": operatorOrValue,
                "value": value,
                "boolean": "AND"
            })
        }
        return this
    }
    
    public function orWhere(column: any, operatorOrValue: any = null, value: any = null) any {
        if typeof(column) == "FUNCTION" {
            return this._whereNested(column, "OR")
        }
        
        if value == null {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": "=",
                "value": operatorOrValue,
                "boolean": "OR"
            })
        } else {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": operatorOrValue,
                "value": value,
                "boolean": "OR"
            })
        }
        return this
    }
    
    public function whereNot(column: any, operatorOrValue: any = null, value: any = null) any {
        if typeof(column) == "FUNCTION" {
            return this._whereNested(column, "AND NOT")
        }
        
        if value == null {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": "!=",
                "value": operatorOrValue,
                "boolean": "AND"
            })
        } else {
            // NOT (column operator value)
            this._wheres.push(map[string]any{
                "type": "not",
                "column": column,
                "operator": operatorOrValue,
                "value": value,
                "boolean": "AND"
            })
        }
        return this
    }
    
    public function orWhereNot(column: any, operatorOrValue: any = null, value: any = null) any {
        if typeof(column) == "FUNCTION" {
            return this._whereNested(column, "OR NOT")
        }
        
        if value == null {
            this._wheres.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": "!=",
                "value": operatorOrValue,
                "boolean": "OR"
            })
        } else {
            this._wheres.push(map[string]any{
                "type": "not",
                "column": column,
                "operator": operatorOrValue,
                "value": value,
                "boolean": "OR"
            })
        }
        return this
    }
    
    // WHERE IN
    public function whereIn(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "in",
            "column": column,
            "values": values,
            "not": false,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNotIn(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "in",
            "column": column,
            "values": values,
            "not": true,
            "boolean": "AND"
        })
        return this
    }
    
    public function orWhereIn(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "in",
            "column": column,
            "values": values,
            "not": false,
            "boolean": "OR"
        })
        return this
    }
    
    public function orWhereNotIn(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "in",
            "column": column,
            "values": values,
            "not": true,
            "boolean": "OR"
        })
        return this
    }
    
    // WHERE NULL
    public function whereNull(column: string) any {
        this._wheres.push(map[string]any{
            "type": "null",
            "column": column,
            "not": false,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNotNull(column: string) any {
        this._wheres.push(map[string]any{
            "type": "null",
            "column": column,
            "not": true,
            "boolean": "AND"
        })
        return this
    }
    
    public function orWhereNull(column: string) any {
        this._wheres.push(map[string]any{
            "type": "null",
            "column": column,
            "not": false,
            "boolean": "OR"
        })
        return this
    }
    
    public function orWhereNotNull(column: string) any {
        this._wheres.push(map[string]any{
            "type": "null",
            "column": column,
            "not": true,
            "boolean": "OR"
        })
        return this
    }
    
    // WHERE BETWEEN
    public function whereBetween(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "between",
            "column": column,
            "values": values,
            "not": false,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNotBetween(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "between",
            "column": column,
            "values": values,
            "not": true,
            "boolean": "AND"
        })
        return this
    }
    
    public function orWhereBetween(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "between",
            "column": column,
            "values": values,
            "not": false,
            "boolean": "OR"
        })
        return this
    }
    
    public function orWhereNotBetween(column: string, values: any) any {
        this._wheres.push(map[string]any{
            "type": "between",
            "column": column,
            "values": values,
            "not": true,
            "boolean": "OR"
        })
        return this
    }
    
    // WHERE LIKE
    public function whereLike(column: string, value: string) any {
        this._wheres.push(map[string]any{
            "type": "like",
            "column": column,
            "value": value,
            "not": false,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNotLike(column: string, value: string) any {
        this._wheres.push(map[string]any{
            "type": "like",
            "column": column,
            "value": value,
            "not": true,
            "boolean": "AND"
        })
        return this
    }
    
    public function orWhereLike(column: string, value: string) any {
        this._wheres.push(map[string]any{
            "type": "like",
            "column": column,
            "value": value,
            "not": false,
            "boolean": "OR"
        })
        return this
    }
    
    public function orWhereNotLike(column: string, value: string) any {
        this._wheres.push(map[string]any{
            "type": "like",
            "column": column,
            "value": value,
            "not": true,
            "boolean": "OR"
        })
        return this
    }
    
    // WHERE COLUMN
    public function whereColumn(first: string, operatorOrSecond: any, second: string = "") any {
        if second == "" {
            this._wheres.push(map[string]any{
                "type": "column",
                "first": first,
                "operator": "=",
                "second": operatorOrSecond,
                "boolean": "AND"
            })
        } else {
            this._wheres.push(map[string]any{
                "type": "column",
                "first": first,
                "operator": operatorOrSecond,
                "second": second,
                "boolean": "AND"
            })
        }
        return this
    }
    
    // WHERE ANY/ALL/NONE
    public function whereAny(columns: any, operator: string, value: any) any {
        this._wheres.push(map[string]any{
            "type": "any",
            "columns": columns,
            "operator": operator,
            "value": value,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereAll(columns: any, operator: string, value: any) any {
        this._wheres.push(map[string]any{
            "type": "all",
            "columns": columns,
            "operator": operator,
            "value": value,
            "boolean": "AND"
        })
        return this
    }
    
    public function whereNone(columns: any, operator: string, value: any) any {
        this._wheres.push(map[string]any{
            "type": "none",
            "columns": columns,
            "operator": operator,
            "value": value,
            "boolean": "AND"
        })
        return this
    }
    
    // WHERE RAW
    public function whereRaw(sql: string, bindings: any = {}) any {
        this._wheres.push(map[string]any{
            "type": "raw",
            "sql": sql,
            "boolean": "AND"
        })
        this._addBindings(bindings)
        return this
    }
    
    public function orWhereRaw(sql: string, bindings: any = {}) any {
        this._wheres.push(map[string]any{
            "type": "raw",
            "sql": sql,
            "boolean": "OR"
        })
        this._addBindings(bindings)
        return this
    }
    
    // 嵌套条件
    private function _whereNested(callback: any, boolean: string) any {
        // 创建子查询构建器
        nested := new QueryBuilder(this._connection, this._table)
        // 调用回调
        callback(nested)
        // 将子查询的条件添加到当前查询
        if len(nested._wheres) > 0 {
            this._wheres.push(map[string]any{
                "type": "nested",
                "query": nested,
                "boolean": boolean
            })
        }
        return this
    }
    
    // ==================== ORDER BY ====================
    
    public function orderBy(column: string, direction: string = "asc") any {
        dir := direction.upper()
        if dir != "ASC" && dir != "DESC" {
            dir = "ASC"
        }
        this._orders.push(map[string]any{
            "type": "column",
            "column": column,
            "direction": dir
        })
        return this
    }
    
    public function orderByDesc(column: string) any {
        return this.orderBy(column, "desc")
    }
    
    public function orderByRaw(sql: string, bindings: any = {}) any {
        this._orderRaw = sql
        this._addBindings(bindings)
        return this
    }
    
    public function latest(column: string = "created_at") any {
        return this.orderBy(column, "desc")
    }
    
    public function oldest(column: string = "created_at") any {
        return this.orderBy(column, "asc")
    }
    
    // ==================== GROUP BY ====================
    
    public function groupBy(columns: any) any {
        if typeof(columns) == "ARRAY" {
            for i := 0; i < len(columns); i++ {
                this._groups.push(columns[i])
            }
        } else {
            this._groups.push(columns)
        }
        return this
    }
    
    // ==================== HAVING ====================
    
    public function having(column: string, operatorOrValue: any = null, value: any = null) any {
        if value == null {
            this._havings.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": "=",
                "value": operatorOrValue,
                "boolean": "AND"
            })
        } else {
            this._havings.push(map[string]any{
                "type": "basic",
                "column": column,
                "operator": operatorOrValue,
                "value": value,
                "boolean": "AND"
            })
        }
        return this
    }
    
    public function havingRaw(sql: string, bindings: any = {}) any {
        this._havingRaw = sql
        this._addBindings(bindings)
        return this
    }
    
    // ==================== LIMIT / OFFSET ====================
    
    public function limit(limit: int) any {
        this._limit = limit
        return this
    }
    
    public function offset(offset: int) any {
        this._offset = offset
        return this
    }
    
    public function take(limit: int) any {
        return this.limit(limit)
    }
    
    public function skip(offset: int) any {
        return this.offset(offset)
    }
    
    public function forPage(page: int, perPage: int = 15) any {
        return this.offset((page - 1) * perPage).limit(perPage)
    }
    
    // ==================== 执行查询 ====================
    
    public function get() any {
        sql := this._compileSelect()
        return this._connection.select(sql, this._bindings)
    }
    
    public function toSql() string {
        return this._compileSelect()
    }
    
    public function first() any {
        this.limit(1)
        results := this.get()
        if len(results) > 0 {
            return results[0]
        }
        return null
    }
    
    public function find(id: any) any {
        return this.where("id", id).first()
    }
    
    public function exists() bool {
        sql := "SELECT 1 FROM " + this._table + this._compileWheres() + " LIMIT 1"
        result := this._connection.select(sql, this._bindings)
        return len(result) > 0
    }
    
    public function count(column: string = "*") int {
        sql := "SELECT COUNT(" + column + ") AS aggregate FROM " + this._table + this._compileWheres() + this._compileGroups()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return parseInt(toString(result[0]["aggregate"]))
        }
        return 0
    }
    
    public function max(column: string) any {
        sql := "SELECT MAX(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function min(column: string) any {
        sql := "SELECT MIN(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function avg(column: string) any {
        sql := "SELECT AVG(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function sum(column: string) any {
        sql := "SELECT SUM(" + column + ") AS aggregate FROM " + this._table + this._compileWheres()
        result := this._connection.select(sql, this._bindings)
        if len(result) > 0 {
            return result[0]["aggregate"]
        }
        return null
    }
    
    public function value(column: string) any {
        result := this.select(column).first()
        if result != null && isset(result, column) {
            return result[column]
        }
        return null
    }
    
    public function pluck(column: string, key: string = "") any {
        results := this.get()
        if key == "" {
            values := {}
            for i := 0; i < len(results); i++ {
                if isset(results[i], column) {
                    values.push(results[i][column])
                }
            }
            return values
        } else {
            values := map[string]any{}
            for i := 0; i < len(results); i++ {
                if isset(results[i], column) && isset(results[i], key) {
                    k := toString(results[i][key])
                    values[k] = results[i][column]
                }
            }
            return values
        }
    }
    
    // ==================== INSERT / UPDATE / DELETE ====================
    
    public function insert(data: any) bool {
        sql := this._compileInsert(data)
        return this._connection.statement(sql, this._bindings)
    }
    
    public function insertGetId(data: any) int {
        sql := this._compileInsert(data)
        return this._connection.insertGetId(sql, this._bindings)
    }
    
    public function update(data: any) int {
        sql := this._compileUpdate(data)
        return this._connection.update(sql, this._bindings)
    }
    
    public function delete() int {
        sql := this._compileDelete()
        return this._connection.delete(sql, this._bindings)
    }
    
    public function increment(column: string, amount: int = 1, extra: any = {}) int {
        sets := column + " = " + column + " + " + toString(amount)
        for key, value := range extra {
            sets = sets + ", " + key + " = " + this._connection._formatValue(value)
        }
        sql := "UPDATE " + this._table + " SET " + sets + this._compileWheres()
        return this._connection.update(sql, this._bindings)
    }
    
    public function decrement(column: string, amount: int = 1, extra: any = {}) int {
        sets := column + " = " + column + " - " + toString(amount)
        for key, value := range extra {
            sets = sets + ", " + key + " = " + this._connection._formatValue(value)
        }
        sql := "UPDATE " + this._table + " SET " + sets + this._compileWheres()
        return this._connection.update(sql, this._bindings)
    }
    
    // ==================== 内部编译方法 ====================
    
    private function _addBindings(bindings: any) {
        for i := 0; i < len(bindings); i++ {
            this._bindings.push(bindings[i])
        }
    }
    
    private function _compileSelect() string {
        sql := "SELECT "
        
        if this._distinct {
            sql = sql + "DISTINCT "
        }
        
        if this._selectRaw != "" {
            sql = sql + this._selectRaw
        } else if len(this._columns) == 0 {
            sql = sql + "*"
        } else {
            sql = sql + this._implode(this._columns, ", ")
        }
        
        sql = sql + " FROM " + this._table
        sql = sql + this._compileJoins()
        sql = sql + this._compileWheres()
        sql = sql + this._compileGroups()
        sql = sql + this._compileHavings()
        sql = sql + this._compileOrders()
        sql = sql + this._compileLimit()
        
        return sql
    }
    
    private function _compileInsert(data: any) string {
        columns := {}
        values := {}
        
        for key, value := range data {
            columns.push(key)
            values.push(this._connection._formatValue(value))
        }
        
        return "INSERT INTO " + this._table + " (" + this._implode(columns, ", ") + ") VALUES (" + this._implode(values, ", ") + ")"
    }
    
    private function _compileUpdate(data: any) string {
        setParts := {}
        
        for key, value := range data {
            setParts.push(key + " = " + this._connection._formatValue(value))
        }
        
        return "UPDATE " + this._table + " SET " + this._implode(setParts, ", ") + this._compileWheres()
    }
    
    private function _compileDelete() string {
        return "DELETE FROM " + this._table + this._compileWheres()
    }
    
    private function _compileWheres() string {
        if len(this._wheres) == 0 {
            return ""
        }
        
        sql := " WHERE "
        
        for i := 0; i < len(this._wheres); i++ {
            w := this._wheres[i]
            
            if i > 0 {
                boolOp := "AND"
                if isset(w, "boolean") {
                    boolOp = toString(w["boolean"])
                }
                sql = sql + " " + boolOp + " "
            }
            
            wType := w["type"]
            
            if wType == "basic" {
                sql = sql + w["column"] + " " + w["operator"] + " " + this._connection._formatValue(w["value"])
            } else if wType == "not" {
                sql = sql + "NOT (" + w["column"] + " " + w["operator"] + " " + this._connection._formatValue(w["value"]) + ")"
            } else if wType == "in" {
                values := w["values"]
                valueStrs := {}
                for j := 0; j < len(values); j++ {
                    valueStrs.push(this._connection._formatValue(values[j]))
                }
                inStr := this._implode(valueStrs, ", ")
                if w["not"] {
                    sql = sql + w["column"] + " NOT IN (" + inStr + ")"
                } else {
                    sql = sql + w["column"] + " IN (" + inStr + ")"
                }
            } else if wType == "null" {
                if w["not"] {
                    sql = sql + w["column"] + " IS NOT NULL"
                } else {
                    sql = sql + w["column"] + " IS NULL"
                }
            } else if wType == "between" {
                values := w["values"]
                if w["not"] {
                    sql = sql + w["column"] + " NOT BETWEEN " + this._connection._formatValue(values[0]) + " AND " + this._connection._formatValue(values[1])
                } else {
                    sql = sql + w["column"] + " BETWEEN " + this._connection._formatValue(values[0]) + " AND " + this._connection._formatValue(values[1])
                }
            } else if wType == "like" {
                if w["not"] {
                    sql = sql + w["column"] + " NOT LIKE " + this._connection._formatValue(w["value"])
                } else {
                    sql = sql + w["column"] + " LIKE " + this._connection._formatValue(w["value"])
                }
            } else if wType == "column" {
                sql = sql + w["first"] + " " + w["operator"] + " " + w["second"]
            } else if wType == "raw" {
                sql = sql + w["sql"]
            } else if wType == "nested" {
                nested := w["query"]
                nestedSql := nested._compileWheresContent()
                sql = sql + "(" + nestedSql + ")"
            } else if wType == "any" {
                // (col1 op val OR col2 op val OR ...)
                columns := w["columns"]
                parts := {}
                for j := 0; j < len(columns); j++ {
                    parts.push(columns[j] + " " + w["operator"] + " " + this._connection._formatValue(w["value"]))
                }
                sql = sql + "(" + this._implode(parts, " OR ") + ")"
            } else if wType == "all" {
                // (col1 op val AND col2 op val AND ...)
                columns := w["columns"]
                parts := {}
                for j := 0; j < len(columns); j++ {
                    parts.push(columns[j] + " " + w["operator"] + " " + this._connection._formatValue(w["value"]))
                }
                sql = sql + "(" + this._implode(parts, " AND ") + ")"
            } else if wType == "none" {
                // NOT (col1 op val OR col2 op val OR ...)
                columns := w["columns"]
                parts := {}
                for j := 0; j < len(columns); j++ {
                    parts.push(columns[j] + " " + w["operator"] + " " + this._connection._formatValue(w["value"]))
                }
                sql = sql + "NOT (" + this._implode(parts, " OR ") + ")"
            }
        }
        
        return sql
    }
    
    // 编译 WHERE 内容（不含 WHERE 关键字，用于嵌套）
    private function _compileWheresContent() string {
        if len(this._wheres) == 0 {
            return "1=1"
        }
        
        sql := ""
        first := true
        
        for i := 0; i < len(this._wheres); i++ {
            w := this._wheres[i]
            
            if !first {
                sql = sql + " " + w["boolean"] + " "
            }
            first = false
            
            wType := w["type"]
            
            if wType == "basic" {
                sql = sql + w["column"] + " " + w["operator"] + " " + this._connection._formatValue(w["value"])
            } else if wType == "in" {
                values := w["values"]
                valueStrs := {}
                for j := 0; j < len(values); j++ {
                    valueStrs.push(this._connection._formatValue(values[j]))
                }
                inStr := this._implode(valueStrs, ", ")
                if w["not"] {
                    sql = sql + w["column"] + " NOT IN (" + inStr + ")"
                } else {
                    sql = sql + w["column"] + " IN (" + inStr + ")"
                }
            } else if wType == "null" {
                if w["not"] {
                    sql = sql + w["column"] + " IS NOT NULL"
                } else {
                    sql = sql + w["column"] + " IS NULL"
                }
            } else if wType == "like" {
                if w["not"] {
                    sql = sql + w["column"] + " NOT LIKE " + this._connection._formatValue(w["value"])
                } else {
                    sql = sql + w["column"] + " LIKE " + this._connection._formatValue(w["value"])
                }
            }
        }
        
        return sql
    }
    
    private function _compileJoins() string {
        if len(this._joins) == 0 {
            return ""
        }
        
        sql := ""
        for i := 0; i < len(this._joins); i++ {
            j := this._joins[i]
            sql = sql + " " + j["type"] + " JOIN " + j["table"]
            sql = sql + " ON " + j["first"] + " " + j["operator"] + " " + j["second"]
        }
        
        return sql
    }
    
    private function _compileOrders() string {
        if this._orderRaw != "" {
            return " ORDER BY " + this._orderRaw
        }
        
        if len(this._orders) == 0 {
            return ""
        }
        
        parts := {}
        for i := 0; i < len(this._orders); i++ {
            order := this._orders[i]
            parts.push(order["column"] + " " + order["direction"])
        }
        
        return " ORDER BY " + this._implode(parts, ", ")
    }
    
    private function _compileGroups() string {
        if len(this._groups) == 0 {
            return ""
        }
        return " GROUP BY " + this._implode(this._groups, ", ")
    }
    
    private function _compileHavings() string {
        if this._havingRaw != "" {
            return " HAVING " + this._havingRaw
        }
        
        if len(this._havings) == 0 {
            return ""
        }
        
        sql := " HAVING "
        first := true
        
        for i := 0; i < len(this._havings); i++ {
            h := this._havings[i]
            
            if !first {
                sql = sql + " " + h["boolean"] + " "
            }
            first = false
            
            sql = sql + h["column"] + " " + h["operator"] + " " + this._connection._formatValue(h["value"])
        }
        
        return sql
    }
    
    private function _compileLimit() string {
        limitSql := ""
        if this._limit > 0 {
            limitSql = " LIMIT " + toString(this._limit)
        }
        if this._offset > 0 {
            limitSql = limitSql + " OFFSET " + toString(this._offset)
        }
        return limitSql
    }
    
    private function _implode(arr: any, separator: string) string {
        if len(arr) == 0 {
            return ""
        }
        result := toString(arr[0])
        for i := 1; i < len(arr); i++ {
            result = result + separator + toString(arr[i])
        }
        return result
    }
}


namespace Database.Mysql

use System.Net.TcpClient

/**
 * Client - MySQL 数据库客户端
 * 
 * 纯 LongLang 实现的 MySQL 客户端，支持 MySQL 协议
 * 
 * 使用示例：
 *   use Database.Mysql.Client
 *   use Database.Mysql.Config
 *   
 *   config := new Config()
 *   config.setHost("127.0.0.1")
 *         .setUsername("root")
 *         .setPassword("root")
 *         .setDatabase("longlang")
 *   
 *   client := Client::connect(config)
 *   result := client.query("SELECT * FROM users")
 *   client.close()
 */
public class Client {
    private _tcp any
    private _config any
    private _connected bool
    private _sequenceId int
    private _serverVersion string
    private _connectionId int
    private _charset int
    
    
    public function __construct() {
        this._connected = false
        this._sequenceId = 0
        this._serverVersion = ""
        this._connectionId = 0
        this._charset = 45  // utf8mb4_general_ci
    }
    
    // ========== 静态工厂方法 ==========
    
    /**
     * 使用配置连接
     */
    public static function connect(config: Config) Client {
        client := new Client()
        client._config = config
        client._doConnect()
        return client
    }
    
    /**
     * 快速连接
     */
    public static function connectSimple(host: string, port: int, username: string, password: string, database: string) Client {
        config := new Config()
        config.setHost(host)
              .setPort(port)
              .setUsername(username)
              .setPassword(password)
              .setDatabase(database)
        return Client::connect(config)
    }
    
    // ========== 连接管理 ==========
    
    /**
     * 执行连接和认证
     */
    private function _doConnect() {
        // 建立 TCP 连接
        this._tcp = new TcpClient(this._config.getHost(), this._config.getPort())
        
        // 读取握手包
        this._readHandshake()
        
        // 发送认证包
        this._sendAuth()
        
        // 读取认证响应
        this._readAuthResponse()
        
        this._connected = true
        
        // 如果指定了数据库，选择数据库
        if this._config.getDatabase() != "" {
            this.selectDatabase(this._config.getDatabase())
        }
        
        // 设置字符集
        this.execute("SET NAMES " + this._config.getCharset())
    }
    
    /**
     * 读取握手包
     */
    private function _readHandshake() {
        packet := this._readPacket()
        
        // 协议版本
        protocolVersion := packet[0]
        if protocolVersion != 10 {
            throw new MysqlException("不支持的 MySQL 协议版本: " + toString(protocolVersion))
        }
        
        // 服务器版本（null-terminated string）
        pos := 1
        serverVersionEnd := pos
        for serverVersionEnd < len(packet) && packet[serverVersionEnd] != 0 {
            serverVersionEnd = serverVersionEnd + 1
        }
        this._serverVersion = this._bytesToString(packet, pos, serverVersionEnd - pos)
        pos = serverVersionEnd + 1
        
        // 连接 ID (4 bytes, little endian)
        this._connectionId = this._readInt32LE(packet, pos)
        pos = pos + 4
        
        // Auth plugin data part 1 (8 bytes)
        authData1 := this._sliceBytes(packet, pos, 8)
        pos = pos + 8
        
        // 填充字节
        pos = pos + 1
        
        // 能力标志低 2 字节
        pos = pos + 2
        
        // 字符集
        if pos < len(packet) {
            this._charset = packet[pos]
            pos = pos + 1
        }
        
        // 状态标志
        pos = pos + 2
        
        // 能力标志高 2 字节
        pos = pos + 2
        
        // Auth plugin data length
        authDataLen := 0
        if pos < len(packet) {
            authDataLen = packet[pos]
            pos = pos + 1
        }
        
        // 保留字节
        pos = pos + 10
        
        // Auth plugin data part 2
        authData2Len := 0
        if authDataLen > 8 {
            authData2Len = authDataLen - 8
        } else {
            authData2Len = 12
        }
        
        authData2 := {}
        if pos + authData2Len <= len(packet) {
            authData2 = this._sliceBytes(packet, pos, authData2Len)
        }
        
        // 合并 auth data（用于密码加密）
        this._authData = this._concatBytes(authData1, authData2)
        
        // 去掉末尾的 null 字节
        for len(this._authData) > 0 && this._authData[len(this._authData) - 1] == 0 {
            this._authData = this._sliceBytes(this._authData, 0, len(this._authData) - 1)
        }
    }
    
    private _authData any  // 存储认证数据
    
    /**
     * 发送认证包
     */
    private function _sendAuth() {
        // 客户端能力标志
        // CLIENT_LONG_PASSWORD(1) | CLIENT_FOUND_ROWS(2) | CLIENT_LONG_FLAG(4) | 
        // CLIENT_PROTOCOL_41(512) | CLIENT_SECURE_CONNECTION(32768) | CLIENT_PLUGIN_AUTH(524288)
        clientFlags := 1 | 2 | 4 | 512 | 32768 | 524288
        
        if this._config.getDatabase() != "" {
            // CLIENT_CONNECT_WITH_DB = 8
            clientFlags = clientFlags | 8
        }
        
        // 构建认证包
        packet := {}
        
        // 能力标志 (4 bytes)
        packet = this._concatBytes(packet, this._writeInt32LE(clientFlags))
        
        // 最大包大小 (4 bytes)
        packet = this._concatBytes(packet, this._writeInt32LE(16777215))
        
        // 字符集 (1 byte)
        packet.push(this._charset)
        
        // 保留字节 (23 bytes)
        for i := 0; i < 23; i++ {
            packet.push(0)
        }
        
        // 用户名 (null-terminated)
        username := this._config.getUsername()
        for i := 0; i < len(username); i++ {
            packet.push(ord(username.charAt(i)))
        }
        packet.push(0)
        
        // 密码（加密后）
        password := this._config.getPassword()
        if password != "" {
            authResponse := this._encryptPassword(password, this._authData)
            packet.push(len(authResponse))
            packet = this._concatBytes(packet, authResponse)
        } else {
            packet.push(0)
        }
        
        // 数据库名 (null-terminated, if database specified)
        if this._config.getDatabase() != "" {
            database := this._config.getDatabase()
            for i := 0; i < len(database); i++ {
                packet.push(ord(database.charAt(i)))
            }
            packet.push(0)
        }
        
        // 认证插件名 (null-terminated)
        pluginName := "mysql_native_password"
        for i := 0; i < len(pluginName); i++ {
            packet.push(ord(pluginName.charAt(i)))
        }
        packet.push(0)
        
        this._writePacket(packet)
    }
    
    /**
     * MySQL 密码加密（mysql_native_password）
     * SHA1(password) XOR SHA1(scramble + SHA1(SHA1(password)))
     */
    private function _encryptPassword(password: string, scramble: any) any {
        // SHA1(password)
        stage1 := __sha1(password)
        
        // SHA1(SHA1(password))
        stage2 := __sha1(stage1)
        
        // scramble + SHA1(SHA1(password))
        combined := this._concatBytes(scramble, stage2)
        
        // SHA1(scramble + SHA1(SHA1(password)))
        stage3 := __sha1(combined)
        
        // SHA1(password) XOR SHA1(scramble + SHA1(SHA1(password)))
        return __bytes_xor(stage1, stage3)
    }
    
    /**
     * 读取认证响应
     */
    private function _readAuthResponse() {
        packet := this._readPacket()
        
        if len(packet) == 0 {
            throw new MysqlException("认证失败：收到空响应")
        }
        
        firstByte := packet[0]
        
        // ERR_PACKET = 0xff, OK_PACKET = 0x00, EOF_PACKET = 0xfe
        if firstByte == 0xff {
            this._handleError(packet)
        } else if firstByte == 0x00 {
            // 认证成功
            return
        } else if firstByte == 0xfe {
            // Auth Switch Request - 服务器要求切换认证插件
            this._handleAuthSwitch(packet)
        } else {
            throw new MysqlException("未知的认证响应: " + toString(firstByte))
        }
    }
    
    /**
     * 处理认证插件切换
     */
    private function _handleAuthSwitch(packet: any) {
        // 跳过第一个字节 (0xfe)
        pos := 1
        
        // 读取插件名（null-terminated）
        pluginEnd := pos
        for pluginEnd < len(packet) && packet[pluginEnd] != 0 {
            pluginEnd = pluginEnd + 1
        }
        pluginName := this._bytesToString(packet, pos, pluginEnd - pos)
        pos = pluginEnd + 1
        
        // 读取新的 auth data（scramble）
        newAuthData := this._sliceBytes(packet, pos, len(packet) - pos)
        // 去掉末尾的 null 字节
        for len(newAuthData) > 0 && newAuthData[len(newAuthData) - 1] == 0 {
            newAuthData = this._sliceBytes(newAuthData, 0, len(newAuthData) - 1)
        }
        
        // 根据插件名生成响应
        if pluginName == "mysql_native_password" {
            // 使用 mysql_native_password 认证
            authResponse := this._encryptPassword(this._config.getPassword(), newAuthData)
            this._writePacket(authResponse)
        } else if pluginName == "caching_sha2_password" {
            // 简单支持 caching_sha2_password：发送密码的 SHA256
            // 注意：这不是完整实现，但对于本地连接通常够用
            authResponse := this._encryptPasswordSha256(this._config.getPassword(), newAuthData)
            this._writePacket(authResponse)
        } else {
            throw new MysqlException("不支持的认证插件: " + pluginName)
        }
        
        // 读取新的响应
        response := this._readPacket()
        
        if len(response) == 0 {
            throw new MysqlException("认证切换失败：收到空响应")
        }
        
        if response[0] == 0xff {
            this._handleError(response)
        } else if response[0] == 0x00 {
            // 认证成功
            return
        } else if response[0] == 0x01 {
            // caching_sha2_password 需要更多数据（Fast Auth）
            // 对于明文连接，发送密码
            this._handleFastAuthResult(response)
        } else {
            throw new MysqlException("认证切换后收到未知响应: " + toString(response[0]))
        }
    }
    
    /**
     * caching_sha2_password 密码加密
     * SHA256(password) XOR SHA256(SHA256(SHA256(password)) + scramble)
     */
    private function _encryptPasswordSha256(password: string, scramble: any) any {
        if password == "" {
            return {}
        }
        
        // SHA256(password)
        stage1 := __sha256(password)
        
        // SHA256(SHA256(password))
        stage2 := __sha256(stage1)
        
        // SHA256(SHA256(SHA256(password)) + scramble)
        combined := this._concatBytes(stage2, scramble)
        stage3 := __sha256(combined)
        
        // SHA256(password) XOR SHA256(...)
        return __bytes_xor(stage1, stage3)
    }
    
    /**
     * 处理 caching_sha2_password Fast Auth 结果
     */
    private function _handleFastAuthResult(packet: any) {
        // 0x01 0x03 = Fast Auth 成功，需要读取 OK 包
        // 0x01 0x04 = 需要完整认证（发送密码）
        if len(packet) >= 2 {
            if packet[1] == 0x03 {
                // Fast Auth 成功，读取 OK 包
                okPacket := this._readPacket()
                if okPacket[0] != 0x00 {
                    throw new MysqlException("Fast Auth 后未收到 OK 包")
                }
                return
            } else if packet[1] == 0x04 {
                // 需要发送密码（对于非 SSL 连接，MySQL 8 默认不允许）
                throw new MysqlException("MySQL 服务器要求加密连接。请在 MySQL 配置中将用户认证方式改为 mysql_native_password，或使用 SSL 连接")
            }
        }
        throw new MysqlException("未知的 Fast Auth 结果")
    }
    
    /**
     * 检查是否已连接
     */
    public function isConnected() bool {
        return this._connected
    }
    
    /**
     * 获取服务器版本
     */
    public function getServerVersion() string {
        return this._serverVersion
    }
    
    /**
     * 获取连接 ID
     */
    public function getConnectionId() int {
        return this._connectionId
    }
    
    // ========== SQL 执行 ==========
    
    /**
     * 执行查询（SELECT）
     */
    public function query(sql: string) Result {
        this._sendCommand(0x03, sql)  // COM_QUERY = 0x03
        return this._readQueryResult()
    }
    
    /**
     * 执行语句（INSERT/UPDATE/DELETE）
     */
    public function execute(sql: string) Result {
        this._sendCommand(0x03, sql)  // COM_QUERY = 0x03
        return this._readExecuteResult()
    }
    
    /**
     * 选择数据库
     */
    public function selectDatabase(database: string) bool {
        this._sendCommand(0x02, database)  // COM_INIT_DB = 0x02
        packet := this._readPacket()
        
        if packet[0] == 0xff {  // ERR_PACKET
            this._handleError(packet)
        }
        
        return packet[0] == 0x00  // OK_PACKET
    }
    
    /**
     * Ping 服务器
     */
    public function ping() bool {
        this._sendCommand(0x0e, "")  // COM_PING = 0x0e
        packet := this._readPacket()
        return packet[0] == 0x00  // OK_PACKET
    }
    
    /**
     * 关闭连接
     */
    public function close() {
        if this._connected {
            try {
                this._sendCommand(0x01, "")  // COM_QUIT = 0x01
            } catch (Exception e) {
                // 忽略关闭时的错误
            }
            this._tcp.close()
            this._connected = false
        }
    }
    
    // ========== 事务支持 ==========
    
    /**
     * 开始事务
     */
    public function beginTransaction() bool {
        result := this.execute("START TRANSACTION")
        return result.affectedRows() >= 0
    }
    
    /**
     * 提交事务
     */
    public function commit() bool {
        result := this.execute("COMMIT")
        return result.affectedRows() >= 0
    }
    
    /**
     * 回滚事务
     */
    public function rollback() bool {
        result := this.execute("ROLLBACK")
        return result.affectedRows() >= 0
    }
    
    // ========== 便捷方法 ==========
    
    /**
     * 获取单行结果
     */
    public function fetchOne(sql: string) Row {
        result := this.query(sql)
        return result.first()
    }
    
    /**
     * 获取所有结果
     */
    public function fetchAll(sql: string) any {
        result := this.query(sql)
        return result.toArray()
    }
    
    /**
     * 获取单个值
     */
    public function fetchScalar(sql: string) any {
        result := this.query(sql)
        return result.scalar()
    }
    
    /**
     * 转义字符串（防止 SQL 注入）
     */
    public function escape(str: string) string {
        result := ""
        for i := 0; i < len(str); i++ {
            ch := charAt(str, i)
            if ch == "'" {
                result = result + "\\'"
            } else if ch == "\"" {
                result = result + "\\\""
            } else if ch == "\\" {
                result = result + "\\\\"
            } else if ch == "\n" {
                result = result + "\\n"
            } else if ch == "\r" {
                result = result + "\\r"
            } else if ch == "\t" {
                result = result + "\\t"
            } else {
                result = result + ch
            }
        }
        return result
    }
    
    // ========== 协议实现（私有方法）==========
    
    /**
     * 发送命令
     */
    private function _sendCommand(command: int, data: string) {
        this._sequenceId = 0
        
        packet := {command}
        for i := 0; i < len(data); i++ {
            packet.push(ord(data.charAt(i)))
        }
        
        this._writePacket(packet)
    }
    
    /**
     * 读取查询结果
     */
    private function _readQueryResult() Result {
        result := new Result()
        
        // 读取第一个包
        packet := this._readPacket()
        
        if len(packet) == 0 {
            throw new MysqlException("收到空响应")
        }
        
        firstByte := packet[0]
        
        // 错误包
        // ERR_PACKET = 0xff
        if firstByte == 0xff {
            this._handleError(packet)
        }
        
        // OK 包（没有结果集）OK_PACKET = 0x00
        if firstByte == 0x00 {
            this._parseOkPacket(packet, result)
            return result
        }
        
        // 结果集
        columnCount := this._readLengthEncodedInt(packet, 0)
        
        // 读取列定义
        columns := {}
        for i := 0; i < columnCount; i++ {
            colPacket := this._readPacket()
            colName := this._parseColumnDefinition(colPacket)
            columns.push(colName)
        }
        result.setColumns(columns)
        
        // 读取 EOF 包（列定义结束）
        eofPacket := this._readPacket()
        // EOF_PACKET = 0xfe
        if eofPacket[0] != 0xfe {
            throw new MysqlException("期望 EOF 包，得到: " + toString(eofPacket[0]))
        }
        
        // 读取行数据
        for true {
            rowPacket := this._readPacket()
            
            // EOF_PACKET = 0xfe
            if rowPacket[0] == 0xfe {
                // 结果集结束
                break
            }
            
            // ERR_PACKET = 0xff
            if rowPacket[0] == 0xff {
                this._handleError(rowPacket)
            }
            
            // 解析行数据
            rowData := this._parseRowData(rowPacket, columns)
            row := new Row(rowData, columns)
            result.addRow(row)
        }
        
        return result
    }
    
    /**
     * 读取执行结果（INSERT/UPDATE/DELETE）
     */
    private function _readExecuteResult() Result {
        result := new Result()
        
        packet := this._readPacket()
        
        // ERR_PACKET = 0xff
        if packet[0] == 0xff {
            this._handleError(packet)
        }
        
        // OK_PACKET = 0x00
        if packet[0] == 0x00 {
            this._parseOkPacket(packet, result)
        }
        
        return result
    }
    
    /**
     * 解析 OK 包
     */
    private function _parseOkPacket(packet: any, result: Result) {
        pos := 1  // 跳过第一个字节
        
        // 受影响行数
        affectedRows := this._readLengthEncodedInt(packet, pos)
        result.setAffectedRows(affectedRows)
        pos = pos + this._lengthEncodedIntSize(affectedRows)
        
        // 最后插入 ID
        lastInsertId := this._readLengthEncodedInt(packet, pos)
        result.setInsertId(lastInsertId)
    }
    
    /**
     * 解析列定义
     */
    private function _parseColumnDefinition(packet: any) string {
        pos := 0
        
        // 跳过 catalog (length-encoded string)
        pos = pos + this._skipLengthEncodedString(packet, pos)
        
        // 跳过 schema
        pos = pos + this._skipLengthEncodedString(packet, pos)
        
        // 跳过 table
        pos = pos + this._skipLengthEncodedString(packet, pos)
        
        // 跳过 org_table
        pos = pos + this._skipLengthEncodedString(packet, pos)
        
        // 读取列名
        nameLen := packet[pos]
        pos = pos + 1
        name := this._bytesToString(packet, pos, nameLen)
        
        return name
    }
    
    /**
     * 解析行数据
     */
    private function _parseRowData(packet: any, columns: any) any {
        data := map[string]any{}
        pos := 0
        
        for i := 0; i < len(columns); i++ {
            colName := columns[i]
            
            // 检查 NULL 值
            if packet[pos] == 0xfb {
                data[colName] = null
                pos = pos + 1
                continue
            }
            
            // 读取 length-encoded string
            strLen := this._readLengthEncodedInt(packet, pos)
            pos = pos + this._lengthEncodedIntSize(strLen)
            
            value := this._bytesToString(packet, pos, strLen)
            data[colName] = value
            pos = pos + strLen
        }
        
        return data
    }
    
    /**
     * 处理错误包
     */
    private function _handleError(packet: any) {
        // 跳过第一个字节 (0xff)
        pos := 1
        
        // 错误码 (2 bytes)
        errorCode := this._readInt16LE(packet, pos)
        pos = pos + 2
        
        // SQL 状态 (1 byte '#' + 5 bytes state)
        sqlState := ""
        if pos < len(packet) && packet[pos] == 35 {  // '#'
            pos = pos + 1
            sqlState = this._bytesToString(packet, pos, 5)
            pos = pos + 5
        }
        
        // 错误消息
        message := this._bytesToString(packet, pos, len(packet) - pos)
        
        throw new MysqlException(message, errorCode, sqlState)
    }
    
    // ========== 包读写 ==========
    
    /**
     * 读取一个包
     */
    private function _readPacket() any {
        // 读取包头 (3 bytes length + 1 byte sequence id)
        header := this._readExact(4)
        if len(header) < 4 {
            throw new MysqlException("读取包头失败")
        }
        
        // 解析长度 (3 bytes, little endian)
        packetLen := header[0] + header[1] * 256 + header[2] * 65536
        
        // 序列号 - 读取后递增，为下次写入准备
        this._sequenceId = header[3] + 1
        
        // 读取包体
        if packetLen == 0 {
            return {}
        }
        
        body := this._readExact(packetLen)
        if len(body) < packetLen {
            throw new MysqlException("读取包体失败，期望 " + toString(packetLen) + " 字节，实际 " + toString(len(body)) + " 字节")
        }
        
        return body
    }
    
    /**
     * 读取精确字节数
     */
    private function _readExact(count: int) any {
        result := {}
        remaining := count
        
        for remaining > 0 {
            chunk := this._tcp.read(remaining)
            if len(chunk) == 0 {
                break
            }
            for i := 0; i < len(chunk); i++ {
                result.push(chunk[i])
            }
            remaining = remaining - len(chunk)
        }
        
        return result
    }
    
    /**
     * 写入一个包
     */
    private function _writePacket(data: any) {
        packetLen := len(data)
        
        // 构建包头
        header := {
            packetLen & 0xff,
            (packetLen >> 8) & 0xff,
            (packetLen >> 16) & 0xff,
            this._sequenceId
        }
        
        // 发送包头和数据
        this._tcp.writeBytes(header)
        this._tcp.writeBytes(data)
        this._tcp.flush()
        
        this._sequenceId = this._sequenceId + 1
    }
    
    // ========== 辅助方法 ==========
    
    private function _bytesToString(bytes: any, offset: int, length: int) string {
        result := ""
        for i := 0; i < length && (offset + i) < len(bytes); i++ {
            result = result + chr(bytes[offset + i])
        }
        return result
    }
    
    private function _sliceBytes(bytes: any, offset: int, length: int) any {
        result := {}
        for i := 0; i < length && (offset + i) < len(bytes); i++ {
            result.push(bytes[offset + i])
        }
        return result
    }
    
    private function _concatBytes(a: any, b: any) any {
        result := {}
        for i := 0; i < len(a); i++ {
            result.push(a[i])
        }
        for i := 0; i < len(b); i++ {
            result.push(b[i])
        }
        return result
    }
    
    private function _readInt16LE(bytes: any, offset: int) int {
        return bytes[offset] + bytes[offset + 1] * 256
    }
    
    private function _readInt32LE(bytes: any, offset: int) int {
        return bytes[offset] + bytes[offset + 1] * 256 + 
               bytes[offset + 2] * 65536 + bytes[offset + 3] * 16777216
    }
    
    private function _writeInt32LE(value: int) any {
        return {
            value & 0xff,
            (value >> 8) & 0xff,
            (value >> 16) & 0xff,
            (value >> 24) & 0xff
        }
    }
    
    private function _readLengthEncodedInt(bytes: any, offset: int) int {
        if offset >= len(bytes) {
            return 0
        }
        
        firstByte := bytes[offset]
        
        if firstByte < 251 {
            return firstByte
        } else if firstByte == 252 {
            return this._readInt16LE(bytes, offset + 1)
        } else if firstByte == 253 {
            return bytes[offset + 1] + bytes[offset + 2] * 256 + bytes[offset + 3] * 65536
        } else if firstByte == 254 {
            return this._readInt32LE(bytes, offset + 1)  // 简化处理，只读 4 字节
        }
        
        return 0
    }
    
    private function _lengthEncodedIntSize(value: int) int {
        if value < 251 {
            return 1
        } else if value < 65536 {
            return 3
        } else if value < 16777216 {
            return 4
        }
        return 9
    }
    
    private function _skipLengthEncodedString(bytes: any, offset: int) int {
        length := this._readLengthEncodedInt(bytes, offset)
        headerSize := this._lengthEncodedIntSize(length)
        return headerSize + length
    }
}




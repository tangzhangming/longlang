# 切片操作 (Slice)

LongLang 支持 Go 风格的切片语法，用于获取数组或字符串的子序列。

## 语法

```
expression[start:end]   // 从 start 到 end-1
expression[start:]      // 从 start 到末尾
expression[:end]        // 从开头到 end-1
expression[:]           // 整个序列的副本
```

## 数组切片

```longlang
var arr = []int{10, 20, 30, 40, 50}

// 基本切片
arr[1:3]    // {20, 30} - 从索引1到索引2
arr[2:]     // {30, 40, 50} - 从索引2到末尾
arr[:3]     // {10, 20, 30} - 从开头到索引2
arr[:]      // {10, 20, 30, 40, 50} - 整个数组副本

// 空切片
arr[2:2]    // {} - 起始和结束相同时返回空数组

// 使用变量作为索引
var start = 1
var end = 4
arr[start:end]  // {20, 30, 40}
```

## 字符串切片

字符串切片返回子字符串，支持 Unicode 字符：

```longlang
var str = "Hello, World!"

str[0:5]    // "Hello"
str[7:]     // "World!"
str[:5]     // "Hello"
str[:]      // "Hello, World!"

// 中文字符串
var chinese = "你好世界"
chinese[0:2]    // "你好"
chinese[2:]     // "世界"
```

## 链式切片

可以对切片结果再次切片：

```longlang
var arr = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

arr[2:8][1:4]   // {4, 5, 6}
// 第一次切片 arr[2:8] = {3, 4, 5, 6, 7, 8}
// 第二次切片 [1:4] = {4, 5, 6}
```

## 特性

- **Go 兼容**: 语法与 Go 完全一致
- **Unicode 支持**: 字符串切片按字符（rune）计算，正确处理中文等多字节字符
- **新数组**: 切片操作返回新数组/字符串，不会修改原数组
- **边界检查**: 自动进行边界检查，防止越界

## 错误处理

```longlang
var arr = []int{1, 2, 3}

// 以下操作会报错
arr[3:1]    // 错误：起始索引大于结束索引
```

## 与 Go 的对比

| 语法 | Go | LongLang | 结果 |
|------|-----|----------|------|
| `arr[1:3]` | ✓ | ✓ | 从索引1到2 |
| `arr[1:]` | ✓ | ✓ | 从索引1到末尾 |
| `arr[:3]` | ✓ | ✓ | 从开头到索引2 |
| `arr[:]` | ✓ | ✓ | 整个切片 |
| `arr[1:3:5]` | ✓ | ✗ | 三索引切片（容量控制），暂不支持 |

## 注意事项

1. 切片索引从 0 开始
2. `end` 索引是不包含的（即结果不包含 `arr[end]`）
3. 切片返回的是新数组，修改切片不会影响原数组
4. 目前不支持 Go 的三索引切片语法 `arr[low:high:max]`



